<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Socket` struct in crate `nanomsg`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Socket">

    <title>nanomsg::Socket - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>nanomsg</a></p><script>window.sidebarCurrent = {name: 'Socket', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>nanomsg</a>::<wbr><a class='struct' href=''>Socket</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-244' class='srclink' href='../src/nanomsg/src/lib.rs.html#112-114' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Socket {
    // some fields omitted
}</pre><div class='docblock'><p>A type-safe socket wrapper around nanomsg&#39;s own socket implementation. This
provides a safe interface for dealing with initializing the sockets, sending
and receiving messages.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl <a class='struct' href='../nanomsg/struct.Socket.html' title='nanomsg::Socket'>Socket</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-296' class='srclink' href='../src/nanomsg/src/lib.rs.html#215-953' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>(protocol: <a class='enum' href='../nanomsg/enum.Protocol.html' title='nanomsg::Protocol'>Protocol</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='struct' href='../nanomsg/struct.Socket.html' title='nanomsg::Socket'>Socket</a>&gt;</code></h4>
<div class='docblock'><p>Allocate and initialize a new Nanomsg socket which returns
a new file descriptor behind the scene. The safe interface doesn&#39;t
expose any of the underlying file descriptors and such.</p>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>socket</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Pull</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>socket</span>) <span class='op'>=&gt;</span> <span class='ident'>socket</span>,
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>err</span>)
};</pre>

<h1 id='error' class='section-header'><a href='#error'>Error</a></h1>
<ul>
<li><code>AddressFamilyNotSupported</code> : Specified address family is not supported.</li>
<li><code>InvalidArgument</code> : Unknown protocol.</li>
<li><code>TooManyOpenFiles</code> : The limit on the total number of open SP sockets or OS limit for file descriptors has been reached.</li>
<li><code>Terminating</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.new_for_device' class='method'><code>fn <a href='#method.new_for_device' class='fnname'>new_for_device</a>(protocol: <a class='enum' href='../nanomsg/enum.Protocol.html' title='nanomsg::Protocol'>Protocol</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='struct' href='../nanomsg/struct.Socket.html' title='nanomsg::Socket'>Socket</a>&gt;</code></h4>
<div class='docblock'><p>Allocate and initialize a new Nanomsg socket meant to be used in a device</p>

<h1 id='example-1' class='section-header'><a href='#example-1'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s1</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new_for_device</span>(<span class='ident'>Protocol</span>::<span class='ident'>Req</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>s2</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new_for_device</span>(<span class='ident'>Protocol</span>::<span class='ident'>Rep</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>ep1</span> <span class='op'>=</span> <span class='ident'>s1</span>.<span class='ident'>bind</span>(<span class='string'>&quot;ipc:///tmp/new_for_device1.ipc&quot;</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>ep2</span> <span class='op'>=</span> <span class='ident'>s2</span>.<span class='ident'>bind</span>(<span class='string'>&quot;ipc:///tmp/new_for_device2.ipc&quot;</span>).<span class='ident'>unwrap</span>();

<span class='comment'>// And now `Socket::device(&amp;s1, &amp;s2)` can be called to create the device.</span></pre>
</div><h4 id='method.bind' class='method'><code>fn <a href='#method.bind' class='fnname'>bind</a>(&amp;mut self, addr: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='struct' href='../nanomsg/endpoint/struct.Endpoint.html' title='nanomsg::endpoint::Endpoint'>Endpoint</a>&gt;</code></h4>
<div class='docblock'><p>Creating a new socket through <code>Socket::new</code> does <strong>not</strong>
bind that socket to a listening state. Instead, one has to be
explicit in enabling the socket to listen onto a specific address.</p>

<p>That&#39;s what the <code>bind</code> method does. Passing in a raw string like:
&quot;ipc:///tmp/pipeline.ipc&quot; is supported.</p>

<p>Note: This does <strong>not</strong> block the current task. That job
is up to the user of the library by entering a loop.</p>

<h1 id='example-2' class='section-header'><a href='#example-2'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>socket</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Push</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>socket</span>) <span class='op'>=&gt;</span> <span class='ident'>socket</span>,
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>err</span>)
};

<span class='comment'>// Bind the newly created socket to the following address:</span>
<span class='kw'>match</span> <span class='ident'>socket</span>.<span class='ident'>bind</span>(<span class='string'>&quot;ipc:///tmp/bind_doc.ipc&quot;</span>) {
    <span class='prelude-val'>Ok</span>(_) <span class='op'>=&gt;</span> {},
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Failed to bind socket: {}&quot;</span>, <span class='ident'>err</span>)
}</pre>

<h1 id='error-1' class='section-header'><a href='#error-1'>Error</a></h1>
<ul>
<li><code>BadFileDescriptor</code> : The socket is invalid.</li>
<li><code>TooManyOpenFiles</code> : Maximum number of active endpoints was reached.</li>
<li><code>InvalidArgument</code> : The syntax of the supplied address is invalid.</li>
<li><code>NameTooLong</code> : The supplied address is too long.</li>
<li><code>ProtocolNotSupported</code> : The requested transport protocol is not supported.</li>
<li><code>AddressNotAvailable</code> : The requested endpoint is not local.</li>
<li><code>NoDevice</code> : Address specifies a nonexistent interface.</li>
<li><code>AddressInUse</code> : The requested local endpoint is already in use.</li>
<li><code>Terminating</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.connect' class='method'><code>fn <a href='#method.connect' class='fnname'>connect</a>(&amp;mut self, addr: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='struct' href='../nanomsg/endpoint/struct.Endpoint.html' title='nanomsg::endpoint::Endpoint'>Endpoint</a>&gt;</code></h4>
<div class='docblock'><p>Connects the socket to a remote endpoint.
Returns the endpoint on success.</p>

<h1 id='example-3' class='section-header'><a href='#example-3'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>socket</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Pull</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>socket</span>) <span class='op'>=&gt;</span> <span class='ident'>socket</span>,
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>err</span>)
};

<span class='kw'>let</span> <span class='ident'>endpoint</span> <span class='op'>=</span> <span class='kw'>match</span> <span class='ident'>socket</span>.<span class='ident'>connect</span>(<span class='string'>&quot;ipc:///tmp/connect_doc.ipc&quot;</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>ep</span>) <span class='op'>=&gt;</span> <span class='ident'>ep</span>,
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Failed to connect socket: {}&quot;</span>, <span class='ident'>err</span>)
};</pre>

<h1 id='error-2' class='section-header'><a href='#error-2'>Error</a></h1>
<ul>
<li><code>BadFileDescriptor</code> : The socket is invalid.</li>
<li><code>TooManyOpenFiles</code> : Maximum number of active endpoints was reached.</li>
<li><code>InvalidArgument</code> : The syntax of the supplied address is invalid.</li>
<li><code>NameTooLong</code> : The supplied address is too long.</li>
<li><code>ProtocolNotSupported</code> : The requested transport protocol is not supported.</li>
<li><code>NoDevice</code> : Address specifies a nonexistent interface.</li>
<li><code>Terminating</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.nb_read' class='method'><code>fn <a href='#method.nb_read' class='fnname'>nb_read</a>(&amp;mut self, buf: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;mut [</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>Non-blocking version of the <code>read</code> function.
Any bytes exceeding the length specified by <code>buf.len()</code> will be truncated.
Returns the number of bytes of the message stored in the buffer on success.
Please note that it differs from nanomsg&#39;s nn_recv which returns the msg size instead.
An error with the <code>Error::TryAgain</code> kind is returned if there&#39;s no message to receive for the moment.</p>

<h1 id='example-4' class='section-header'><a href='#example-4'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>, <span class='ident'>Error</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Pull</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>endpoint</span> <span class='op'>=</span> <span class='ident'>socket</span>.<span class='ident'>connect</span>(<span class='string'>&quot;ipc:///tmp/nb_read_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>buffer</span> <span class='op'>=</span> [<span class='number'>0u8</span>; <span class='number'>1024</span>];

<span class='kw'>match</span> <span class='ident'>socket</span>.<span class='ident'>nb_read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>buffer</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>count</span>) <span class='op'>=&gt;</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Read {} bytes !&quot;</span>, <span class='ident'>count</span>);
        <span class='comment'>// here we can process the message stored in `buffer`</span>
    },
    <span class='prelude-val'>Err</span>(<span class='ident'>Error</span>::<span class='ident'>TryAgain</span>) <span class='op'>=&gt;</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Nothing to be read for the moment ...&quot;</span>);
        <span class='comment'>// here we can use the CPU for something else and try again later</span>
    },
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Problem while reading: {}&quot;</span>, <span class='ident'>err</span>)
};</pre>

<h1 id='error-3' class='section-header'><a href='#error-3'>Error</a></h1>
<ul>
<li><code>BadFileDescriptor</code> : The socket is invalid.</li>
<li><code>OperationNotSupported</code> : The operation is not supported by this socket type.</li>
<li><code>FileStateMismatch</code> : The operation cannot be performed on this socket at the moment because socket is not in the appropriate state. This error may occur with socket types that switch between several states.</li>
<li><code>TryAgain</code> : Non-blocking mode was requested and there’s no message to receive at the moment.</li>
<li><code>Interrupted</code> : The operation was interrupted by delivery of a signal before the message was received.</li>
<li><code>Terminating</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.nb_read_to_end' class='method'><code>fn <a href='#method.nb_read_to_end' class='fnname'>nb_read_to_end</a>(&amp;mut self, buf: &amp;mut <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a>&gt;) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>Non-blocking version of the <code>read_to_end</code> function.
Copy the message allocated by nanomsg into the buffer on success.
An error with the <code>Error::TryAgain</code> kind is returned if there&#39;s no message to receive for the moment.</p>

<h1 id='example-5' class='section-header'><a href='#example-5'>Example:</a></h1>
<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>allow</span>(<span class='ident'>unstable</span>)]</span>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>, <span class='ident'>Error</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Pull</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>endpoint</span> <span class='op'>=</span> <span class='ident'>socket</span>.<span class='ident'>connect</span>(<span class='string'>&quot;ipc:///tmp/nb_read_to_end_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>buffer</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
<span class='kw'>match</span> <span class='ident'>socket</span>.<span class='ident'>nb_read_to_end</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>buffer</span>) {
    <span class='prelude-val'>Ok</span>(_) <span class='op'>=&gt;</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Read message {} bytes !&quot;</span>, <span class='ident'>buffer</span>.<span class='ident'>len</span>());
        <span class='comment'>// here we can process the message stored in `buffer`</span>
    },
    <span class='prelude-val'>Err</span>(<span class='ident'>Error</span>::<span class='ident'>TryAgain</span>) <span class='op'>=&gt;</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Nothing to be read for the moment ...&quot;</span>);
        <span class='comment'>// here we can use the CPU for something else and try again later</span>
    },
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Problem while reading: {}&quot;</span>, <span class='ident'>err</span>)
};</pre>

<h1 id='error-4' class='section-header'><a href='#error-4'>Error</a></h1>
<ul>
<li><code>BadFileDescriptor</code> : The socket is invalid.</li>
<li><code>OperationNotSupported</code> : The operation is not supported by this socket type.</li>
<li><code>FileStateMismatch</code> : The operation cannot be performed on this socket at the moment because socket is not in the appropriate state. This error may occur with socket types that switch between several states.</li>
<li><code>TryAgain</code> : Non-blocking mode was requested and there’s no message to receive at the moment.</li>
<li><code>Interrupted</code> : The operation was interrupted by delivery of a signal before the message was received.</li>
<li><code>Terminating</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.nb_write' class='method'><code>fn <a href='#method.nb_write' class='fnname'>nb_write</a>(&amp;mut self, buf: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>Non-blocking version of the <code>write</code> function.
An error with the <code>Error::TryAgain</code> kind is returned if the message cannot be sent at the moment.</p>

<h1 id='example-6' class='section-header'><a href='#example-6'>Example:</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>, <span class='ident'>Error</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Push</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>endpoint</span> <span class='op'>=</span> <span class='ident'>socket</span>.<span class='ident'>connect</span>(<span class='string'>&quot;ipc:///tmp/nb_write_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();

<span class='kw'>match</span> <span class='ident'>socket</span>.<span class='ident'>nb_write</span>(<span class='string'>b&quot;foobar&quot;</span>) {
    <span class='prelude-val'>Ok</span>(_) <span class='op'>=&gt;</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Message sent !&quot;</span>); },
    <span class='prelude-val'>Err</span>(<span class='ident'>Error</span>::<span class='ident'>TryAgain</span>) <span class='op'>=&gt;</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Receiver not ready, message can&#39;t be sent for the moment ...&quot;</span>);
    },
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Problem while writing: {}&quot;</span>, <span class='ident'>err</span>)
};</pre>

<h1 id='error-5' class='section-header'><a href='#error-5'>Error</a></h1>
<ul>
<li><code>BadFileDescriptor</code> : The socket is invalid.</li>
<li><code>OperationNotSupported</code> : The operation is not supported by this socket type.</li>
<li><code>FileStateMismatch</code> : The operation cannot be performed on this socket at the moment because socket is not in the appropriate state. This error may occur with socket types that switch between several states.</li>
<li><code>TryAgain</code> : Non-blocking mode was requested and there’s no message to receive at the moment.</li>
<li><code>Interrupted</code> : The operation was interrupted by delivery of a signal before the message was received.</li>
<li><code>Terminating</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.zc_write' class='method'><code>fn <a href='#method.zc_write' class='fnname'>zc_write</a>(&amp;mut self, buf: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>Zero-copy version of the <code>write</code> function.</p>

<h1 id='example-7' class='section-header'><a href='#example-7'>Example:</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>Read</span>, <span class='ident'>Write</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>push_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Push</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>push_endpoint</span> <span class='op'>=</span> <span class='ident'>push_socket</span>.<span class='ident'>bind</span>(<span class='string'>&quot;ipc:///tmp/zc_write_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pull_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Pull</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pull_endpoint</span> <span class='op'>=</span> <span class='ident'>pull_socket</span>.<span class='ident'>connect</span>(<span class='string'>&quot;ipc:///tmp/zc_write_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>msg</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>allocate_msg</span>(<span class='number'>6</span>).<span class='ident'>unwrap</span>();
<span class='ident'>msg</span>[<span class='number'>0</span>] <span class='op'>=</span> <span class='number'>102u8</span>;
<span class='ident'>msg</span>[<span class='number'>1</span>] <span class='op'>=</span> <span class='number'>111u8</span>;
<span class='ident'>msg</span>[<span class='number'>2</span>] <span class='op'>=</span> <span class='number'>111u8</span>;
<span class='ident'>msg</span>[<span class='number'>3</span>] <span class='op'>=</span> <span class='number'>98u8</span>;
<span class='ident'>msg</span>[<span class='number'>4</span>] <span class='op'>=</span> <span class='number'>97u8</span>;
<span class='ident'>msg</span>[<span class='number'>5</span>] <span class='op'>=</span> <span class='number'>114u8</span>;

<span class='kw'>match</span> <span class='ident'>push_socket</span>.<span class='ident'>zc_write</span>(<span class='ident'>msg</span>) {
    <span class='prelude-val'>Ok</span>(_) <span class='op'>=&gt;</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Message sent, do not try to reuse it !&quot;</span>); },
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Problem while writing: {}, msg still available&quot;</span>, <span class='ident'>err</span>)
};
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>text</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='kw'>match</span> <span class='ident'>pull_socket</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>text</span>) {
    <span class='prelude-val'>Ok</span>(_) <span class='op'>=&gt;</span> { <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Message received.&quot;</span>); },
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;{}&quot;</span>, <span class='ident'>err</span>)
}</pre>

<h1 id='error-6' class='section-header'><a href='#error-6'>Error</a></h1>
<ul>
<li><code>BadFileDescriptor</code> : The socket is invalid.</li>
<li><code>OperationNotSupported</code> : The operation is not supported by this socket type.</li>
<li><code>FileStateMismatch</code> : The operation cannot be performed on this socket at the moment because socket is not in the appropriate state. This error may occur with socket types that switch between several states.</li>
<li><code>Interrupted</code> : The operation was interrupted by delivery of a signal before the message was received.</li>
<li><code>Terminating</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.allocate_msg' class='method'><code>fn <a href='#method.allocate_msg' class='fnname'>allocate_msg</a>&lt;'a&gt;(len: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;'a mut [</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>&gt;</code></h4>
<div class='docblock'><p>Allocate a message of the specified size to be sent in zero-copy fashion.
The content of the message is undefined after allocation and it should be filled in by the user.
While <code>write</code> functions allow to send arbitrary buffers,
buffers allocated using <code>allocate_msg</code> can be more efficient for large messages
as they allow for using zero-copy techniques.</p>

<h1 id='error-7' class='section-header'><a href='#error-7'>Error</a></h1>
<ul>
<li><code>InvalidArgument</code> : Supplied allocation type is invalid.</li>
<li><code>Unknown</code> : Out of memory.</li>
</ul>
</div><h4 id='method.free_msg' class='method'><code>fn <a href='#method.free_msg' class='fnname'>free_msg</a>&lt;'a&gt;(msg: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;'a mut [</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Deallocates a message allocated using <code>allocate_msg</code> function</p>

<h1 id='error-8' class='section-header'><a href='#error-8'>Error</a></h1>
<ul>
<li><code>BadAddress</code> : The message pointer is invalid.</li>
</ul>
</div><h4 id='method.new_pollfd' class='method'><code>fn <a href='#method.new_pollfd' class='fnname'>new_pollfd</a>(&amp;self, pollinout: <a class='enum' href='../nanomsg/enum.PollInOut.html' title='nanomsg::PollInOut'>PollInOut</a>) -&gt; <a class='struct' href='../nanomsg/struct.PollFd.html' title='nanomsg::PollFd'>PollFd</a></code></h4>
<div class='docblock'><p>Creates a poll request for the socket with the specified check criteria.
- <strong>pollinout:</strong> See <code>PollInOut</code> for options</p>
</div><h4 id='method.poll' class='method'><code>fn <a href='#method.poll' class='fnname'>poll</a>(request: &amp;mut <a class='struct' href='../nanomsg/struct.PollRequest.html' title='nanomsg::PollRequest'>PollRequest</a>, timeout: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.isize.html'>isize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>Checks a set of sockets and reports whether it’s possible to send a message to the socket and/or receive a message from each socket.
Upon successful completion, the number of <code>PollFd</code> structures with events signaled is returned.</p>

<h1 id='example-8' class='section-header'><a href='#example-8'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>, <span class='ident'>PollFd</span>, <span class='ident'>PollRequest</span>, <span class='ident'>PollInOut</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>left_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Pair</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>left_ep</span> <span class='op'>=</span> <span class='ident'>left_socket</span>.<span class='ident'>bind</span>(<span class='string'>&quot;ipc:///tmp/poll_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>right_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Pair</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>right_ep</span> <span class='op'>=</span> <span class='ident'>right_socket</span>.<span class='ident'>connect</span>(<span class='string'>&quot;ipc:///tmp/poll_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();

<span class='ident'>thread</span>::<span class='ident'>sleep_ms</span>(<span class='number'>10</span>);

<span class='comment'>// Here some messages may have been sent ...</span>

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pollfd_vec</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>PollFd</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>left_socket</span>.<span class='ident'>new_pollfd</span>(<span class='ident'>PollInOut</span>::<span class='ident'>InOut</span>), <span class='ident'>right_socket</span>.<span class='ident'>new_pollfd</span>(<span class='ident'>PollInOut</span>::<span class='ident'>InOut</span>)];
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>poll_req</span> <span class='op'>=</span> <span class='ident'>PollRequest</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>pollfd_vec</span>[..]);
<span class='kw'>let</span> <span class='ident'>timeout</span> <span class='op'>=</span> <span class='number'>10</span>;
<span class='kw'>let</span> <span class='ident'>poll_result</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>poll</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>poll_req</span>, <span class='ident'>timeout</span>);

<span class='kw'>if</span> <span class='ident'>poll_req</span>.<span class='ident'>get_fds</span>()[<span class='number'>0</span>].<span class='ident'>can_write</span>() {
    <span class='comment'>// left_socket socket can send a message ...</span>
}

<span class='kw'>if</span> <span class='ident'>poll_req</span>.<span class='ident'>get_fds</span>()[<span class='number'>1</span>].<span class='ident'>can_read</span>() {
    <span class='comment'>// right_socket socket is ready to receive a message ...</span>
}</pre>

<h1 id='error-9' class='section-header'><a href='#error-9'>Error</a></h1>
<ul>
<li><code>BadFileDescriptor</code> : Some of the provided sockets are invalid.</li>
<li><code>Interrupted</code> : The operation was interrupted by delivery of a signal before the message was received.</li>
<li><code>Timeout</code> : No event was signaled before the specified timeout.</li>
<li><code>Terminating</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.device' class='method'><code>fn <a href='#method.device' class='fnname'>device</a>(socket1: &amp;<a class='struct' href='../nanomsg/struct.Socket.html' title='nanomsg::Socket'>Socket</a>, socket2: &amp;<a class='struct' href='../nanomsg/struct.Socket.html' title='nanomsg::Socket'>Socket</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Starts a device to forward messages between two sockets.
If both sockets are valid, <code>device</code> function loops
and sends and messages received from s1 to s2 and vice versa.
If only one socket is valid and the other is negative,
<code>device</code> works in a &quot;loopback&quot; mode —
it loops and sends any messages received from the socket back to itself.
To break the loop and make <code>device</code> function exit use <code>terminate</code> function.</p>

<h1 id='error-10' class='section-header'><a href='#error-10'>Error</a></h1>
<ul>
<li><code>BadFileDescriptor</code> : Some of the provided sockets are invalid.</li>
<li><code>Interrupted</code> : The operation was interrupted by delivery of a signal before the message was received.</li>
<li><code>InvalidArgument</code> : Either one of the socket is not an AF_SP_RAW socket; or the two sockets don’t belong to the same protocol; or the directionality of the sockets doesn’t fit (e.g. attempt to join two SINK sockets to form a device).</li>
<li><code>Terminating</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.terminate' class='method'><code>fn <a href='#method.terminate' class='fnname'>terminate</a>()</code></h4>
<div class='docblock'><p>Notify all sockets about process termination.
To help with shutdown of multi-threaded programs nanomsg provides the <code>terminate</code> function
which informs all the open sockets that process termination is underway.
If a socket is blocked inside a blocking function, such as <code>read</code>,
it will be unblocked and <code>Terminating</code> error will be returned to the user.
Similarly, any subsequent attempt to invoke a socket function other than <code>drop</code> after <code>terminate</code> was called will result in <code>Terminating</code> error.
If waiting inside a polling function, the call will unblock with both read and write signaled.
The <code>terminate</code> function itself is non-blocking.</p>
</div><h4 id='method.set_linger' class='method'><code>fn <a href='#method.set_linger' class='fnname'>set_linger</a>(&amp;mut self, linger: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.isize.html'>isize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Specifies how long the socket should try to send pending outbound messages after <code>drop</code> have been called.
Negative value means infinite linger. Default value is 1000 (1 second).</p>
</div><h4 id='method.set_send_buffer_size' class='method'><code>fn <a href='#method.set_send_buffer_size' class='fnname'>set_send_buffer_size</a>(&amp;mut self, size_in_bytes: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Size of the send buffer, in bytes. To prevent blocking for messages larger than the buffer,
exactly one message may be buffered in addition to the data in the send buffer.
Default value is 128kB.</p>
</div><h4 id='method.set_receive_buffer_size' class='method'><code>fn <a href='#method.set_receive_buffer_size' class='fnname'>set_receive_buffer_size</a>(&amp;mut self, size_in_bytes: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Size of the receive buffer, in bytes. To prevent blocking for messages larger than the buffer,
exactly one message may be buffered in addition to the data in the receive buffer.
Default value is 128kB.</p>
</div><h4 id='method.set_send_timeout' class='method'><code>fn <a href='#method.set_send_timeout' class='fnname'>set_send_timeout</a>(&amp;mut self, timeout: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.isize.html'>isize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>The timeout for send operation on the socket.
If message cannot be sent within the specified timeout, TryAgain error is returned.
Negative value means infinite timeout. Default value is infinite timeout.</p>
</div><h4 id='method.set_receive_timeout' class='method'><code>fn <a href='#method.set_receive_timeout' class='fnname'>set_receive_timeout</a>(&amp;mut self, timeout: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.isize.html'>isize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>The timeout for recv operation on the socket.
If message cannot be received within the specified timeout, TryAgain error is returned.
Negative value means infinite timeout. Default value is infinite timeout.</p>
</div><h4 id='method.set_reconnect_interval' class='method'><code>fn <a href='#method.set_reconnect_interval' class='fnname'>set_reconnect_interval</a>(&amp;mut self, interval: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.isize.html'>isize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>For connection-based transports such as TCP, this option specifies how long to wait,
when connection is broken before trying to re-establish it.
Note that actual reconnect interval may be randomised to some extent to prevent severe reconnection storms.
Default value is 100 milliseconds.</p>
</div><h4 id='method.set_max_reconnect_interval' class='method'><code>fn <a href='#method.set_max_reconnect_interval' class='fnname'>set_max_reconnect_interval</a>(&amp;mut self, interval: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.isize.html'>isize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>This option is to be used only in addition to <code>set_reconnect_interval</code> option.
It specifies maximum reconnection interval. On each reconnect attempt,
the previous interval is doubled until <code>max_reconnect_interval</code> is reached.
Value of zero means that no exponential backoff is performed and
reconnect interval is based only on <code>reconnect_interval</code>.
If <code>max_reconnect_interval</code> is less than <code>reconnect_interval</code>, it is ignored.
Default value is 0.</p>
</div><h4 id='method.set_send_priority' class='method'><code>fn <a href='#method.set_send_priority' class='fnname'>set_send_priority</a>(&amp;mut self, priority: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Sets outbound priority for endpoints subsequently added to the socket.
This option has no effect on socket types that send messages to all the peers.
However, if the socket type sends each message to a single peer (or a limited set of peers),
peers with high priority take precedence over peers with low priority.
Highest priority is 1, lowest priority is 16. Default value is 8.</p>
</div><h4 id='method.set_receive_priority' class='method'><code>fn <a href='#method.set_receive_priority' class='fnname'>set_receive_priority</a>(&amp;mut self, priority: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Sets inbound priority for endpoints subsequently added to the socket.
This option has no effect on socket types that are not able to receive messages.
When receiving a message, messages from peer with higher priority are received before messages
from peer with lower priority.
Highest priority is 1, lowest priority is 16. Default value is 8.</p>
</div><h4 id='method.set_ipv4_only' class='method'><code>fn <a href='#method.set_ipv4_only' class='fnname'>set_ipv4_only</a>(&amp;mut self, ipv4_only: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>If set to true, only IPv4 addresses are used.
If set to false, both IPv4 and IPv6 addresses are used.
Default value is true.</p>
</div><h4 id='method.set_socket_name' class='method'><code>fn <a href='#method.set_socket_name' class='fnname'>set_socket_name</a>(&amp;mut self, name: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Socket name for error reporting and statistics.
Default value is &quot;socket.N&quot; where N is socket integer.
<strong>This option is experimental, see <code>Socket::env</code> for details</strong></p>
</div><h4 id='method.set_tcp_nodelay' class='method'><code>fn <a href='#method.set_tcp_nodelay' class='fnname'>set_tcp_nodelay</a>(&amp;mut self, tcp_nodelay: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>This option, when set to <code>true</code>, disables Nagle’s algorithm.
It also disables delaying of TCP acknowledgments.
Using this option improves latency at the expense of throughput.</p>
</div><h4 id='method.get_receive_fd' class='method'><code>fn <a href='#method.get_receive_fd' class='fnname'>get_receive_fd</a>(&amp;mut self) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='type' href='https://doc.rust-lang.org/nightly/std/sys/ext/io/type.RawFd.html' title='std::sys::ext::io::RawFd'>RawFd</a>&gt;</code></h4>
<div class='docblock'><p>Retrieve a file descriptor that is readable when a message can
be received on the unerlying socket</p>
</div><h4 id='method.get_send_fd' class='method'><code>fn <a href='#method.get_send_fd' class='fnname'>get_send_fd</a>(&amp;mut self) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='type' href='https://doc.rust-lang.org/nightly/std/sys/ext/io/type.RawFd.html' title='std::sys::ext::io::RawFd'>RawFd</a>&gt;</code></h4>
<div class='docblock'><p>Retrieve a file descriptor that is writeable when a message
can be sent on the underlying socket</p>
</div><h4 id='method.get_socket_name' class='method'><code>fn <a href='#method.get_socket_name' class='fnname'>get_socket_name</a>(&amp;mut self, len: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a>&gt;</code></h4>
<div class='docblock'><p>Retrieve the name for this socket for error reporting and
statistics.
**This option is experimental, see <code>Socket::env</code> for details</p>
</div><h4 id='method.subscribe' class='method'><code>fn <a href='#method.subscribe' class='fnname'>subscribe</a>(&amp;mut self, topic: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Defined on full <code>Sub</code> socket.
Subscribes for a particular topic.
Type of the option is string.
A single <code>Sub</code> socket can handle multiple subscriptions.</p>
</div><h4 id='method.unsubscribe' class='method'><code>fn <a href='#method.unsubscribe' class='fnname'>unsubscribe</a>(&amp;mut self, topic: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Defined on full <code>Sub</code> socket. Unsubscribes from a particular topic.</p>
</div><h4 id='method.set_survey_deadline' class='method'><code>fn <a href='#method.set_survey_deadline' class='fnname'>set_survey_deadline</a>(&amp;mut self, deadline: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.isize.html'>isize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Specifies how long to wait for responses to the survey.
Once the deadline expires, receive function will return <code>Timeout</code> error and all subsequent responses to the survey will be silently dropped.
The deadline is measured in milliseconds. Default value is 1 second.</p>
</div><h4 id='method.set_request_resend_interval' class='method'><code>fn <a href='#method.set_request_resend_interval' class='fnname'>set_request_resend_interval</a>(&amp;mut self, interval: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.isize.html'>isize</a>) -&gt; <a class='type' href='../nanomsg/result/type.Result.html' title='nanomsg::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>This option is defined on the full <code>Req</code> socket.
If reply is not received in specified amount of milliseconds, the request will be automatically resent.
The type of this option is int. Default value is 1 minute.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/std/io/trait.Read.html' title='std::io::Read'>Read</a> for <a class='struct' href='../nanomsg/struct.Socket.html' title='nanomsg::Socket'>Socket</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-463' class='srclink' href='../src/nanomsg/src/lib.rs.html#955-1130' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.read' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Read.html#tymethod.read' class='fnname'>read</a>(&amp;mut self, buf: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;mut [</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='type' href='https://doc.rust-lang.org/nightly/std/io/error/type.Result.html' title='std::io::error::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>Receive a message from the socket and store it in the buffer argument.
Any bytes exceeding the length specified by <code>buffer.len()</code> will be truncated.
Returns the number of bytes of the message stored in the buffer on success.
Please note that it differs from nanomsg&#39;s nn_recv which returns the msg size instead.</p>

<h1 id='example-9' class='section-header'><a href='#example-9'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>Read</span>, <span class='ident'>Write</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>push_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Push</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>push_ep</span> <span class='op'>=</span> <span class='ident'>push_socket</span>.<span class='ident'>bind</span>(<span class='string'>&quot;ipc:///tmp/read_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pull_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Pull</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pull_ep</span> <span class='op'>=</span> <span class='ident'>pull_socket</span>.<span class='ident'>connect</span>(<span class='string'>&quot;ipc:///tmp/read_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>buffer</span> <span class='op'>=</span> [<span class='number'>0u8</span>; <span class='number'>1024</span>];

<span class='ident'>thread</span>::<span class='ident'>sleep_ms</span>(<span class='number'>50</span>);

<span class='kw'>match</span> <span class='ident'>push_socket</span>.<span class='ident'>write</span>(<span class='string'>b&quot;foobar&quot;</span>) {
    <span class='prelude-val'>Ok</span>(..) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Message sent !&quot;</span>),
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Failed to write to the socket: {}&quot;</span>, <span class='ident'>err</span>)
}

<span class='kw'>match</span> <span class='ident'>pull_socket</span>.<span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>buffer</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>count</span>) <span class='op'>=&gt;</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Read {} bytes !&quot;</span>, <span class='ident'>count</span>);
        <span class='comment'>// here we can process the `count` bytes of the message stored in `buffer`</span>
    },
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Problem while reading: {}&quot;</span>, <span class='ident'>err</span>)
};</pre>

<h1 id='error-11' class='section-header'><a href='#error-11'>Error</a></h1>
<ul>
<li><code>io::ErrorKind::FileNotFound</code> : The socket is invalid.</li>
<li><code>io::ErrorKind::MismatchedFileTypeForOperation</code> : The operation is not supported by this socket type.</li>
<li><code>io::ErrorKind::ResourceUnavailable</code> : The operation cannot be performed on this socket at the moment because socket is not in the appropriate state. This error may occur with socket types that switch between several states.</li>
<li><code>io::ErrorKind::TimedOut</code> : Individual socket types may define their own specific timeouts. If such timeout is hit this error will be returned.</li>
<li><code>io::ErrorKind::Interrupted</code> : The operation was interrupted by delivery of a signal before the message was received.</li>
<li><code>io::ErrorKind::Other</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.read_to_end' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_to_end' class='fnname'>read_to_end</a>(&amp;mut self, buf: &amp;mut <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a>&gt;) -&gt; <a class='type' href='https://doc.rust-lang.org/nightly/std/io/error/type.Result.html' title='std::io::error::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>Receive a message from the socket. Copy the message allocated by nanomsg into the buffer on success.</p>

<h1 id='example-10' class='section-header'><a href='#example-10'>Example:</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>Read</span>, <span class='ident'>Write</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>push_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Push</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>push_ep</span> <span class='op'>=</span> <span class='ident'>push_socket</span>.<span class='ident'>bind</span>(<span class='string'>&quot;ipc:///tmp/read_to_end_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pull_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Pull</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pull_ep</span> <span class='op'>=</span> <span class='ident'>pull_socket</span>.<span class='ident'>connect</span>(<span class='string'>&quot;ipc:///tmp/read_to_end_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();

<span class='ident'>thread</span>::<span class='ident'>sleep_ms</span>(<span class='number'>50</span>);

<span class='kw'>match</span> <span class='ident'>push_socket</span>.<span class='ident'>write</span>(<span class='string'>b&quot;foobar&quot;</span>) {
    <span class='prelude-val'>Ok</span>(..) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Message sent !&quot;</span>),
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Failed to write to the socket: {}&quot;</span>, <span class='ident'>err</span>)
}

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>msg</span> <span class='op'>=</span> <span class='ident'>Vec</span>::<span class='ident'>new</span>();
<span class='kw'>match</span> <span class='ident'>pull_socket</span>.<span class='ident'>read_to_end</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>msg</span>) {
    <span class='prelude-val'>Ok</span>(_) <span class='op'>=&gt;</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Read {} bytes !&quot;</span>, <span class='ident'>msg</span>.<span class='ident'>len</span>());
        <span class='comment'>// here we can process the the message stored in `msg`</span>
    },
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Problem while reading: {}&quot;</span>, <span class='ident'>err</span>)
};</pre>

<h1 id='error-12' class='section-header'><a href='#error-12'>Error</a></h1>
<ul>
<li><code>io::ErrorKind::FileNotFound</code> : The socket is invalid.</li>
<li><code>io::ErrorKind::MismatchedFileTypeForOperation</code> : The operation is not supported by this socket type.</li>
<li><code>io::ErrorKind::ResourceUnavailable</code> : The operation cannot be performed on this socket at the moment because socket is not in the appropriate state. This error may occur with socket types that switch between several states.</li>
<li><code>io::ErrorKind::TimedOut</code> : Individual socket types may define their own specific timeouts. If such timeout is hit this error will be returned.</li>
<li><code>io::ErrorKind::Interrupted</code> : The operation was interrupted by delivery of a signal before the message was received.</li>
<li><code>io::ErrorKind::Other</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.read_to_string' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_to_string' class='fnname'>read_to_string</a>(&amp;mut self, buf: &amp;mut <a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a>) -&gt; <a class='type' href='https://doc.rust-lang.org/nightly/std/io/error/type.Result.html' title='std::io::error::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>Receive a message from the socket. Copy the message allocated by nanomsg into the buffer on success.
If the data in the message is not valid UTF-8 then an error is returned and buffer is unchanged.</p>

<h1 id='example-11' class='section-header'><a href='#example-11'>Example:</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>Read</span>, <span class='ident'>Write</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>push_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Push</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>push_ep</span> <span class='op'>=</span> <span class='ident'>push_socket</span>.<span class='ident'>bind</span>(<span class='string'>&quot;ipc:///tmp/read_to_string_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pull_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Pull</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pull_ep</span> <span class='op'>=</span> <span class='ident'>pull_socket</span>.<span class='ident'>connect</span>(<span class='string'>&quot;ipc:///tmp/read_to_string_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();

<span class='ident'>thread</span>::<span class='ident'>sleep_ms</span>(<span class='number'>50</span>);

<span class='kw'>match</span> <span class='ident'>push_socket</span>.<span class='ident'>write</span>(<span class='string'>b&quot;foobar&quot;</span>) {
    <span class='prelude-val'>Ok</span>(..) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Message sent !&quot;</span>),
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Failed to write to the socket: {}&quot;</span>, <span class='ident'>err</span>)
}

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>msg</span> <span class='op'>=</span> <span class='ident'>String</span>::<span class='ident'>new</span>();
<span class='kw'>match</span> <span class='ident'>pull_socket</span>.<span class='ident'>read_to_string</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>msg</span>) {
    <span class='prelude-val'>Ok</span>(_) <span class='op'>=&gt;</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Read {} bytes !&quot;</span>, <span class='ident'>msg</span>.<span class='ident'>len</span>());
        <span class='comment'>// here we can process the the message stored in `msg`</span>
    },
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Problem while reading: {}&quot;</span>, <span class='ident'>err</span>)
};</pre>

<h1 id='errors' class='section-header'><a href='#errors'>Errors</a></h1>
<ul>
<li><code>io::ErrorKind::FileNotFound</code> : The socket is invalid.</li>
<li><code>io::ErrorKind::MismatchedFileTypeForOperation</code> : The operation is not supported by this socket type.</li>
<li><code>io::ErrorKind::ResourceUnavailable</code> : The operation cannot be performed on this socket at the moment because socket is not in the appropriate state. This error may occur with socket types that switch between several states.</li>
<li><code>io::ErrorKind::TimedOut</code> : Individual socket types may define their own specific timeouts. If such timeout is hit this error will be returned.</li>
<li><code>io::ErrorKind::Interrupted</code> : The operation was interrupted by delivery of a signal before the message was received.</li>
<li><code>io::ErrorKind::Other</code> : The library is terminating, or the message is not a valid UTF-8 string.</li>
</ul>
</div><h4 id='method.read_exact' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_exact' class='fnname'>read_exact</a>(&amp;mut self, buf: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;mut [</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>,&nbsp;<a class='struct' href='https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html' title='std::io::error::Error'>Error</a>&gt;</code><div class='since' title='Stable since Rust version 1.6.0'>1.6.0</div></h4>
<div class='docblock'><p>Read the exact number of bytes required to fill <code>buf</code>. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.read_exact">Read more</a></p>
</div><h4 id='method.by_ref' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.by_ref' class='fnname'>by_ref</a>(&amp;mut self) -&gt; &amp;mut Self</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></h4>
<div class='docblock'><p>Creates a &quot;by reference&quot; adaptor for this instance of <code>Read</code>. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.by_ref">Read more</a></p>
</div><h4 id='method.bytes' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.bytes' class='fnname'>bytes</a>(self) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/std/io/struct.Bytes.html' title='std::io::Bytes'>Bytes</a>&lt;Self&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></h4>
<div class='docblock'><p>Transforms this <code>Read</code> instance to an <code>Iterator</code> over its bytes. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.bytes">Read more</a></p>
</div><h4 id='method.chars' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.chars' class='fnname'>chars</a>(self) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/std/io/struct.Chars.html' title='std::io::Chars'>Chars</a>&lt;Self&gt;</code></h4>
<div class='stability'><em class='stab unstable'>Unstable (<code>io</code>)<p>: the semantics of a partial read/write of where errors happen is currently unclear and may change</p>
</em></div><div class='docblock'><p>Transforms this <code>Read</code> instance to an <code>Iterator</code> over <code>char</code>s. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.chars">Read more</a></p>
</div><h4 id='method.chain' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.chain' class='fnname'>chain</a>&lt;R&gt;(self, next: R) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/std/io/struct.Chain.html' title='std::io::Chain'>Chain</a>&lt;Self,&nbsp;R&gt; <span class='where'>where R: <a class='trait' href='https://doc.rust-lang.org/nightly/std/io/trait.Read.html' title='std::io::Read'>Read</a></span></code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></h4>
<div class='docblock'><p>Creates an adaptor which will chain this stream with another. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.chain">Read more</a></p>
</div><h4 id='method.take' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.take' class='fnname'>take</a>(self, limit: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a>) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/std/io/struct.Take.html' title='std::io::Take'>Take</a>&lt;Self&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></h4>
<div class='docblock'><p>Creates an adaptor which will read at most <code>limit</code> bytes from it. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html#method.take">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html' title='std::io::Write'>Write</a> for <a class='struct' href='../nanomsg/struct.Socket.html' title='nanomsg::Socket'>Socket</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-493' class='srclink' href='../src/nanomsg/src/lib.rs.html#1132-1187' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.write' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.write' class='fnname'>write</a>(&amp;mut self, buf: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='type' href='https://doc.rust-lang.org/nightly/std/io/error/type.Result.html' title='std::io::error::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.usize.html'>usize</a>&gt;</code></h4>
<div class='docblock'><p>The function will send a message containing the data from the buf parameter to the socket.
Which of the peers the message will be sent to is determined by the particular socket type.</p>

<h1 id='example-12' class='section-header'><a href='#example-12'>Example:</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>nanomsg</span>::{<span class='ident'>Socket</span>, <span class='ident'>Protocol</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::{<span class='ident'>Read</span>, <span class='ident'>Write</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>push_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Push</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>push_ep</span> <span class='op'>=</span> <span class='ident'>push_socket</span>.<span class='ident'>bind</span>(<span class='string'>&quot;ipc:///tmp/write_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pull_socket</span> <span class='op'>=</span> <span class='ident'>Socket</span>::<span class='ident'>new</span>(<span class='ident'>Protocol</span>::<span class='ident'>Pull</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>pull_ep</span> <span class='op'>=</span> <span class='ident'>pull_socket</span>.<span class='ident'>connect</span>(<span class='string'>&quot;ipc:///tmp/write_doc.ipc&quot;</span>).<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>buffer</span> <span class='op'>=</span> [<span class='number'>0u8</span>; <span class='number'>1024</span>];

<span class='ident'>thread</span>::<span class='ident'>sleep_ms</span>(<span class='number'>50</span>);

<span class='kw'>match</span> <span class='ident'>push_socket</span>.<span class='ident'>write_all</span>(<span class='string'>b&quot;foobar&quot;</span>) {
    <span class='prelude-val'>Ok</span>(..) <span class='op'>=&gt;</span> <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Message sent !&quot;</span>),
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Failed to write to the socket: {}&quot;</span>, <span class='ident'>err</span>)
}

<span class='kw'>match</span> <span class='ident'>pull_socket</span>.<span class='ident'>read</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>buffer</span>) {
    <span class='prelude-val'>Ok</span>(<span class='ident'>count</span>) <span class='op'>=&gt;</span> {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;Read {} bytes !&quot;</span>, <span class='ident'>count</span>);
        <span class='comment'>// here we can process the `count` bytes of the message stored in `buffer`</span>
    },
    <span class='prelude-val'>Err</span>(<span class='ident'>err</span>) <span class='op'>=&gt;</span> <span class='macro'>panic</span><span class='macro'>!</span>(<span class='string'>&quot;Problem while reading: {}&quot;</span>, <span class='ident'>err</span>)
};</pre>

<h1 id='error-13' class='section-header'><a href='#error-13'>Error</a></h1>
<ul>
<li><code>io::ErrorKind::FileNotFound</code> : The socket is invalid.</li>
<li><code>io::ErrorKind::MismatchedFileTypeForOperation</code> : The operation is not supported by this socket type.</li>
<li><code>io::ErrorKind::ResourceUnavailable</code> : The operation cannot be performed on this socket at the moment because socket is not in the appropriate state. This error may occur with socket types that switch between several states.</li>
<li><code>io::ErrorKind::Interrupted</code> : The operation was interrupted by delivery of a signal before the message was received.</li>
<li><code>io::ErrorKind::TimedOut</code> : Individual socket types may define their own specific timeouts. If such timeout is hit this error will be returned.</li>
<li><code>io::ErrorKind::Other</code> : The library is terminating.</li>
</ul>
</div><h4 id='method.flush' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.flush' class='fnname'>flush</a>(&amp;mut self) -&gt; <a class='type' href='https://doc.rust-lang.org/nightly/std/io/error/type.Result.html' title='std::io::error::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Flush this output stream, ensuring that all intermediately buffered contents reach their destination. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#tymethod.flush">Read more</a></p>
</div><h4 id='method.write_all' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_all' class='fnname'>write_all</a>(&amp;mut self, buf: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u8.html'>u8</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>,&nbsp;<a class='struct' href='https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html' title='std::io::error::Error'>Error</a>&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></h4>
<div class='docblock'><p>Attempts to write an entire buffer into this write. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_all">Read more</a></p>
</div><h4 id='method.write_fmt' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_fmt' class='fnname'>write_fmt</a>(&amp;mut self, fmt: <a class='struct' href='https://doc.rust-lang.org/nightly/core/fmt/struct.Arguments.html' title='core::fmt::Arguments'>Arguments</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>,&nbsp;<a class='struct' href='https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html' title='std::io::error::Error'>Error</a>&gt;</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></h4>
<div class='docblock'><p>Writes a formatted string into this writer, returning any error encountered. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.write_fmt">Read more</a></p>
</div><h4 id='method.by_ref-1' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.by_ref' class='fnname'>by_ref</a>(&amp;mut self) -&gt; &amp;mut Self</code><div class='since' title='Stable since Rust version 1.0.0'>1.0.0</div></h4>
<div class='docblock'><p>Creates a &quot;by reference&quot; adaptor for this instance of <code>Write</code>. <a href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html#method.by_ref">Read more</a></p>
</div></div><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Drop.html' title='core::ops::Drop'>Drop</a> for <a class='struct' href='../nanomsg/struct.Socket.html' title='nanomsg::Socket'>Socket</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-504' class='srclink' href='../src/nanomsg/src/lib.rs.html#1189-1197' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.drop' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/ops/trait.Drop.html#tymethod.drop' class='fnname'>drop</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Closes the socket.
Any buffered inbound messages that were not yet received by the application will be discarded.
The library will try to deliver any outstanding outbound messages for the time specified by <code>set_linger</code>.
The call will block in the meantime.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "nanomsg";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>